// АНОНИМНЫЕ ФУНКЦИИ //
// Если после function есть имя то эта функция будет именнованая в любых других случаях аннонимная

// const sum = function (a, b) { // Такая функция являеться анонимной так как после function не никакого имени
// return a + b;
// };

// const sum2 = new Function('a','b', 'return a + b');

// console.log(sum);
// console.log(sum2);
//   |
//   |
// вывела консоль
// ƒ (a, b) {     // первая без имени
//     return a + b;
//     }
//     scriptFunc.js:11 ƒ anonymous(a,b // вторая анонимная, но к ней никак нельзя обратиться
//     ) {
//     return a + b
//     }

// Анониманя функция может иметь имя если мы её присваиваем к какой-то переменной. Т.е
//Функция присваиваться по ссылке в переменную. наша функция будет храниться в памяти без имени

// Есть онониманя функция вызывающая сама себя
// (function() { // такой способ используеться для инкапсуляции когды мы хотим огородит код от окружающих
//     console.log('Hello');
// })();


// CallBack Funcion // MUST HAVE //

 // в качестве параметров функции мы можем принимать не только значения 
 // или перменные но и функции, т.е. передать функцию callback и выполнять её внутри нашей функици.
 // назвают такие функиции - функции обратного вызова и любая функция которая передаётся как аргумент
 // называет функцией обратного вызова и она может быть анонимной

// const doNum = function(a, b, CallBack){
// if (typeof a === 'number' && typeof b === 'number'){ // проверяем какие нам данные пришли
//     CallBack(a, b); //В таком случае буду выполнять CallBack функцию и передвавать туда этиже числа a и b
// }
// };
// // вызываем функцию doNum передаём числа 5 и 10 и передаём анонимную функцию
// doNum(5, 10, function(a, b){  //Работает это так, т.е на место функции callback строчка -(41) у нас будет 
//     // подствалена function(a, b) которую мы передали третьим параметром в фукницю doNum
//     console.log(a + b);
// });


// // Можем передать именнованную функцию
// function mult (a, b) {
//     console.log(a * b);
// }
// doNum(3, 5, mult);

// для чего нужная функция callBack.
// В  нашем случае java исполнил функции по очерёдно сначало one затем two/ 
// Но не всегда мы можем быть уверены что функции сработают в своём порядке, потому может мыть задержка
// в браузере или в других узлах и тогда javaScript не дожидаясь ответа от представленной функции пойдёт
// дальше и так сказать перепрыгнет через нужная для расчётов участок
// Мы с иметировали задержку и получилось что сначало сработал функция two затем one и получилось
// Поел суп ПОТОМ сварил суп, чувствуйте сдесь что-то не то.

// Вписываел callBack
// и выполним её после того как сварим суп
// а передавать я буду туда нашу функцию two

// function one(callBack) {
//     setTimeout(function(){
//         console.log('Сварил суп');
//         callBack();
//     }, 1000);
// }

// function two() {
//  console.log('Поел суп');
// }

// one(two); // получилось что Сварил Суп Поел Суп - теперь всё работает правильно

// function one(callBack) {
//     console.log('Делаем запрос на сервер');
// setTimeout(function(){
//     console.log('Получаем данные от сервера');
//     callBack();
// }, 1500);
// }

// function two() {
//     console.log('Выводим данные на страницу');
// }

// one(two);

// Мы будем использоват очень часто
// callBack функции используються во время обработки события, вызываються только когда событие произошло
// callBack функции использються во время методов перебора foreach
// ПРАВИЛА callback function ВСЕГДА ПЕРЕДАЁТЬСЯ В ДРУГУЮ ФУНКЦИЮ И ВЫПОЛНЯТЬСЯ ПОСЛЕ ВЫПОЛНЕНИЯ ТОЙ ФУНКЦИИ

// ЧИСТЫЕ ФУНКЦИИ //

// Детерминированная функция завист только от входных данных!
// function foo(a, b) {
//     const sum = a + b;
//     return sum;
// }

// console.log(foo(1, 3)); 

//Детерминированная функция + чистая функция
// Чистая функция должная быть детерминированная, а также не должна иметь побочных эффектов
// тоесть эта функция не должная изменять входные данные и не изменять всё что вне этой функции
// побочными эффектами ещё являеться такие действия как вывод в консол, алерт, запись файла, вывод на страницу и тд
// т.е функция должная получить только данные сделать с этими данными операции и вернуть результат причём
// не изменя эти данные.

// Чистые функции проще в понимание и отладки также в тестировании они не зависят от остального кода
// программы и их можно вызывать в любое время при любой погоде, результат будет одинаковый
// чистые функции зависят только от входных данных

